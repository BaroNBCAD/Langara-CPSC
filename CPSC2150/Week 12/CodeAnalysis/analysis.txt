a.
The algorithm is mostly the same EXCEPT the use of closestNeighbor/closestDistance.

1.
closestNeighbor and closestDistance variables are the issues. Let's use the given maze as an example:
{1,1,1,1},
{0,1,0,1},
{0,1,0,1},
{0,1,1,1}

When we track to vertex 1, vertex 2 and 5 both have the distance of 2.
The DFS() given function will always take the vertex 5 as the closestNeighbor, and 2 as the closestDistance whenever the DFS() function runs.

2. While DijkStra's algorithm uses the PriorityQueue, where it finds the smallest distance from ALL THE REMAINING VERTICES,
the algorithm in class only finds the smallest distance from the ADJACENT VERTICES.

b.
There should be an array, a vector, or any type of data structure (PriorityQueue, etc.) to store the closest distance of ALL vertices.
We can also use the vector<int> dist that we have, but need to handle it properly.
I added a function [int lookForClosest(vector<bool> &visited, vector<int> &dist)] where it looks for the closest vertex. It's an O(n) version of PriorityQueue.

c.
1.
/*
if (visited[v2]){
  return;
}
*/
- Even if the visited[v2] is false, the function still does the "return" -> That's why it takes no effect.

2. closestNeighbor and closestDistance need to be well handled.

3. 
/*
  if (v1 == v2){
    return;
  }
*/
Unless you want to look for multiple paths (I don't see why you'd like to do so in the finding the shortest path function), it's better to set visited[v2] = true;
(Might be a good idea to return the DFS() early in case we've found v2 when updating the distance of vertices)

d. Not really.

I upload my code in this Week 12 folder. Please check it out.
